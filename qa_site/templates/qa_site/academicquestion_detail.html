{% extends "core/base.html" %}

{% load static %}
{% load i18n %}
{% load crispy_forms_tags %}
{% load humanize %}
{% load flag_tags %}
{% load app_extras %}  

{% get_current_language as LANGUAGE_CODE %}
{% get_login_url as login_url %}

{% block title %}
<title>{{ question.title }} | CamerSchools</title>
{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/highlight.min.css' %}">
<link rel="stylesheet" href="{% static 'css/jquery-comments.css' %}">
{% endblock %}

{% block extra_script_pre %}
<script type="text/javascript" src="{% static 'ckeditor/ckeditor-init.js' %}"></script>
<script type="text/javascript" src="{% static 'ckeditor/ckeditor/ckeditor.js' %}"></script>
<script type="text/javascript" src="{% static 'ckeditor/ckeditor/adapters/jquery.js' %}"></script>
<script type="text/javascript" src="{% static 'js/highlight.min.js' %}"></script>

{# https://github.com/naugtur/insertionQuery #}
<script src="{% static 'js/insQ.min.js' %}"></script>
<script src="{% static 'js/moment-with-locales.js' %}"></script>
<!-- <script src="{% static 'js/jquery.textcomplete.js' %}"></script> -->
{% comment %} <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.textcomplete/1.8.0/jquery.textcomplete.js"></script> {% endcomment %}
<script src="{% static 'js/jquery-comments.js' %}"></script>
{% endblock %}

{% block institution_searchbox %}
{% endblock %}

{% block content %}
<div class="container-lg">
	<article class="border mb-4 p-3 js-question" data-id="{{ question.id }}">
		<div class="text-end mb-2">
			<a href="{% url 'qa_site:academic-question-create' %}" class="btn btn-warning">
				{% trans 'Ask a Question' %}
			</a>
		</div>
		{% with question_poster=question.poster %}
		<h2 class="question-header__title">
			{% with original_lang=question.original_language %}
			<span {% if question|should_attribute:LANGUAGE_CODE %} lang="{{ original_lang|opposite_language }}-x-mtfrom-{{ original_lang }}" {% endif %}>
				{{ question.title }}
			</span>
			{% include 'core/google_attribution.html' with object=question %}
			{% endwith %}
		</h2>

		{# question-info #}
		<p class="mb-lg-1">
			<span class="mx-1" >
				{% trans 'Asked' %}
				<strong title="{{ question.posted_datetime }}">
					{{ question.posted_datetime|naturaltime }}
				</strong> 
			</span>
			<span class="mx-1">
				{% trans 'By' %}
				{% if question_poster.has_social_profile %}
					{# note that this `border-bottom-dotted` is a custom class, not from bootstrap. #}
					<a 
						class="px-1 bg-info opacity-75 text-decoration-none border-bottom-dotted" 
						href="{{ question_poster.get_absolute_url }}"
					>
						{{ question_poster.username }}
					</a>
				{% else %}
					<span class="px-1 bg-info" title="{% blocktrans %} User doesn't have a social profile {% endblocktrans %}">{{ question_poster.username }}</span>
				{% endif %}
			</span>
			{% if question.subject_id %}
				<span class="mx-1">
					{% trans 'In' %}
					<a href="{% url 'qa_site:academic-question-list' %}?subject={{ question.subject_id }}" class="text-decoration-none ">{{ question.subject.name }}</a>
				</span>
			{% endif %}
			{% with view_count=question.view_count %}
			<p class="mx-1">
				{% trans 'Views' %}:
				<span class="ms-2">
					{{ view_count|format_number }}
					<i class="far fa-eye ms-1" aria-hidden="true"></i>
				</span>
			</p>
			{% endwith %}
		</p>

		<hr class="mb-3">
		<section class="mb-4 px-3 question-layout">
			{% with original_lang=question.original_language %}
			<div class="mt-3 mb-4 question-content" {% if question|should_attribute:LANGUAGE_CODE %} lang="{{ original_lang|opposite_language }}-x-mtfrom-{{ original_lang }}" {% endif %}>
				{{ question.content|safe }}
				{% include 'core/google_attribution.html' with object=question %}
			</div>
			{% endwith %}
			{% if question_tags.exists %}
				<div class="question-taglist">
					{% for tag in question_tags %}
						<span class="badge rounded-pill bg-secondary p-2">
							{{ tag.name }}
						</span>
					{% endfor %}
				</div>
			{% endif %}

			<!-- question-reaction(like, dislike, bookmark, flag) -->
			<div class="mt-3 mb-3 question-reaction">
				<div class="d-inline mx-2 question-reaction-upvote">
					<a 
						role="button" 
						class="text-decoration-none link-primary js-upvote" 
						data-id="{{ question.id }}"
						data-poster-id="{{ question.poster_id }}"
						data-thread="question"
						title="{% trans 'Vote this question UP if it is useful and clear. (click again to undo)' %}"
					>
						{% if user in question.upvoters.all %}
							<i class="fas fa-thumbs-up js-selected" aria-hidden="true"></i>
							{% trans 'Liked' %}
						{% else %}
							<i class="far fa-thumbs-up" aria-hidden="true"></i>
							{% trans 'Like' %}
						{% endif %}
					</a>
					<span class="ms-1 text-success">{{ question.upvote_count|format_number }}</span>
				</div>
				<div class="d-inline mx-2 question-reaction-downvote">
					<a 
						role="button" 
						class="text-decoration-none js-downvote" 
						data-thread="question" 
						data-id="{{ question.id }}"
						data-poster-id="{{ question.poster_id }}"
						title="{% trans 'Vote this question DOWN if it is unclear or not useful. (click again to undo)' %}"
					>
						{% if user in question.downvoters.all %}
							<i class="fas fa-thumbs-down js-selected" aria-hidden="true"></i>
							{% trans 'Disliked' %}
						{% else %}
							<i class="far fa-thumbs-down" aria-hidden="true"></i>
							{% trans 'Dislike' %}
						{% endif %}
					</a>
					<span class="ms-1 text-danger">{{ question.downvote_count|format_number }}</span>
				</div>
				<!-- Bookmark area -->
				<div class="d-inline mx-2">
					{% url 'qa_site:academic-bookmark-toggle' as bookmark_url %}
					{% url 'users:profile-qa' as bookmarks_url %}
					{% trans 'Add this question to your favourites. (click again to undo)' as title_text %}
					{% render_bookmark_template question bookmark_url bookmarks_url title_text %}
				</div>
				<!-- Share area -->
				<div class="d-inline mx-2">
					{% trans 'Share a link to this question' as heading %}
					{% include 'core/social_share_tooltip.html' with heading=heading title=question.title url=request.build_absolute_uri %}
				</div>
				<!-- flag area -->
				{# if question belongs to user, dont display flag widget #}
				{% if user != question_poster %}
					<div class="d-inline float-end">
						{% if user.is_anonymous %}
							<a href="{{ login_url }}?next={{ request.get_full_path }}" class="link-danger text-decoration-none opacity-75">
								{% trans 'Report post' %}
								<span>
									{% include "flag/flag_icon.html" %}
								</span>
							</a>
						{% else %}
							{# js-flagHelper will be used in scripts to modify the flag text after flagging or unflagging #}
							<span class="link-danger opacity-75 js-flagHelper" role="button">
								{% if user|has_flagged:question %} 
									{% trans 'Remove flag' %}
								{% else %} 
									{% trans 'Report post' %} 
								{% endif %}
							</span> 
							<div class="d-inline-block">
								{% render_flag_form question user request %}
							</div>
						{% endif %}
					</div>
				{% else %}
					{% comment %} 
					Normally flag form shouldn't be displayed if current user is poster, but we need
					to in this case due to the comment section... (flagging form need to be rendered on the page).
					{% endcomment %}
					<span class="ms-2">
						| {% render_flag_form question user request False %}
					</span>
				{% endif %}
			</div>

			<!-- edit and delete area -->
			{% if can_edit_question or can_delete_question %}
				<div class="mb-4">
					{% if can_edit_question %}
						<div class="d-inline mx-2">
							<a class="text-decoration-none link-danger" href="{% url 'qa_site:academic-question-update' pk=question.pk %}">
								<i class="fas fa-edit me-1" aria-hidden="true"></i>
								{% trans 'Edit question' %}
							</a>
						</div>
					{% endif %}
					{% if can_delete_question %}
						<div class="d-inline mx-2">
							<a class="text-decoration-none link-danger" href="{% url 'qa_site:academic-question-delete' pk=question.pk %}">
								<i class="fas fa-trash-alt me-1" aria-hidden="true"></i>
								{% trans 'Delete question' %}
							</a>
						</div>
					{% endif %}
				</div>
			{% endif %}

			<!-- follow area -->
			{# if question belongs to user, don't display follow area. #}
			{% if user != question_poster %}
				<p class="mt-4 mb-5">
					<button data-id="{{ question.id }}" class="btn btn-sm {% if is_following %} btn-secondary js-selected {% else %} btn-outline-secondary {% endif %} js-follow-button">
						{% trans 'Click here' %} 
						<i class="fas fa-bullseye" aria-hidden="true"></i>
					</button> 
					<span class="js-follow-unfollow-text">
						{% if is_following %}
							{{ unfollow_text }}
						{% else %}
							{{ follow_text }}
						{% endif %}
					</span>
				</p>
			{% endif %}
		</section>

		{# container for jquery-comments #}
		<section id="academic-qstn-comments"></section>

		{% endwith %}
	</article>

	<!-- Related Questions -->
	{% if related_qstns.exists %}
		<hr class="mb-4">
		<aside class="p-3">
			<h5 class="mb-3">{% trans 'Related Questions' %}</h5>
			{% for question in related_qstns %}
				{% with original_lang=question.original_language question_score=question.score %}
				<div class="mb-2"> <!-- class 'related-question' -->
					<a href="{{ question.get_absolute_url }}" class=" text-decoration-none">
						<span 
							class="
								badge align-middle px-2 py-1 me-2 
								{% if question_score > 0 %} bg-success 
								{% elif question_score < 0 %} bg-danger 
								{% else %} bg-secondary {% endif %}
							"
						>
							{{ question_score }}
						</span>
						<span>
							<span {% if question|should_attribute:LANGUAGE_CODE %} lang="{{ original_lang|opposite_language }}-x-mtfrom-{{ original_lang }}" {% endif %}>
								{{ question.title }}
							</span> - 
							<strong>
								{{ question.num_answers }} 
								{% trans 'answer' %}{{ question.num_answers|pluralize }}
							</strong>
						</span>
					</a>
					<span class="small text-muted mx-2">{{ question.posted_datetime|naturaltime }}</span>
					{% include 'core/google_attribution.html' with object=question %}
					<a class="link-success" href="{{ question.get_absolute_url }}">{% trans 'Answer this' %}</a>
				</div>
				{% endwith %}
			{% endfor %}
		</aside>
	{% else %}
		<br>
	{% endif %}
</div>
{% endblock content %}

{% block extra_js %}
<script>
	// call highlight js to highligt code on page
	hljs.highlightAll();

	/* Get current user's id.. */
	// if user isn't logged in, user.id and userPoints will be "None"
	var userId = "{{ user.id }}", userPoints = "{{ user.site_points }}";
	var requiredDownvotePoints = {{ required_downvote_points }}, posterId = {{ question.poster_id }};
	userId = (userId == "None" ? null : userId);
	var csrfToken = "{{ csrf_token }}";
	// reduce margin of paragraphs so as to use less space..
	$('.js-comment-wrp').children('p').css('margin-bottom', '.2rem');

	/* FLAG FORM */
	// trigger click on flag-report-icon when flag helper is clicked
	$('.js-flagHelper').click(function() {
		var $parentWrp = $(this).parent();
		// console.log($parentWrp);
		$parentWrp.find('.js-flag-report-icon').first().click();
		// $('.js-flag-report-icon').first().click();
	});

	// possible thread types are {question, answer, question-comment, answer-comment}
	var THREAD_TYPES = ["question", "answer", "question-comment", "answer-comment"];
	var $upvoteTriggerer = $('.js-upvote'), $downvoteTriggerer = $('.js-downvote');

	/** for general checks to do before proceeding to upvoting or downvoting */
	function onVote(event) {
		// if user isn't logged in
		if (!userId) {
			// prevent other handlers from being called(prevent sending request to backend)
			event.stopImmediatePropagation();
			displayToast('LOGIN_REQUIRED');
			return false;
		}

		// if thread type is invalid
		var threadType = event.currentTarget.dataset.thread;
		if (!THREAD_TYPES.includes(threadType)) {
			event.stopImmediatePropagation();
			displayToast('ERROR_OCCURRED');
			return false;
		}

		// if user is voting for their post
		if (userId === this.dataset.posterId) {
			event.stopImmediatePropagation();
			displayToast('SELF_VOTE');
			return false;
		}
	}

	$upvoteTriggerer.click(onVote);
	$downvoteTriggerer.click(onVote);

	/* UPVOTES */
	$upvoteTriggerer.click(function() {
		var $this = $(this);
		var $icon = $this.children('i'), id = parseInt(this.dataset.id, 10);
		
		// possible thread types are {question, answer, question-comment, answer-comment}
		var voteType = 'up', threadType = this.dataset.thread;
		var url = "{% url 'qa_site:academic-thread-vote' %}";

		// if user is trying to undo the vote(the upvote)
		if ($icon.hasClass('js-selected')) {
			var voteAction = 'recall-vote';

			$.ajax({
				url: url,
				type: 'POST',
				dataType: 'json',
				data: {id: id, vote_type: voteType, thread_type: threadType, action: voteAction},
				beforeSend: function (xhr) {
					xhr.setRequestHeader("X-CSRFToken", csrfToken);
				},
				success: function(response) {
					// remove fas(font-awesome solid) class and set to far(font-awesome regular)
					$icon.removeClass('fas js-selected').addClass('far');

					// update number of votes
					var $voteCounter = $this.next();
					var prevCount = parseInt($voteCounter.text(), 10);
					$voteCounter.text(prevCount - 1);
					
					// update text
					var textNode = $icon[0].nextSibling;
					textNode.textContent = " {% trans 'Like' %}";
				},
				error: function(jqXHR, status, error) {
					displayToast('CUSTOM_ERROR', jqXHR.responseJSON['message']);
				}
			});
		} else {
			// if user is adding a new vote
			var voteAction = 'vote';

			$.ajax({
				url: url,
				type: 'POST',
				data: {id: id, vote_type: voteType, thread_type: threadType, action: voteAction},
				beforeSend: function (xhr) {
					xhr.setRequestHeader("X-CSRFToken", csrfToken);
				},
				success: function(response) {
					// remove far class and set to fas
					$icon.removeClass('far').addClass('fas js-selected');

					// update count
					var $voteCounter = $this.next();
					var prevCount = parseInt($voteCounter.text(), 10);
					$voteCounter.text(prevCount + 1);

					// update text
					var textNode = $icon[0].nextSibling;
					textNode.textContent = " {% trans 'Liked' %}";
				},
				error: function(jqXHR, status, error) {
					displayToast('CUSTOM_ERROR', jqXHR.responseJSON['message']);
				}
			});
		}
	});

	/* DOWNVOTES */
	$downvoteTriggerer.click(function() {
		var $this = $(this);
		var $icon = $this.children('i'), id = parseInt(this.dataset.id, 10);
		var voteType = 'down', threadType = this.dataset.thread;
		var url = "{% url 'qa_site:academic-thread-vote' %}";

		// if user is trying to undo the vote(the upvote)
		if ($icon.hasClass('js-selected')) {
			var voteAction = 'recall-vote';

			$.ajax({
				url: url,
				type: 'POST',
				data: {id: id, vote_type: voteType, thread_type: threadType, action: voteAction},
				beforeSend: function (xhr) {
					xhr.setRequestHeader("X-CSRFToken", csrfToken);
				},
				success: function(response) {
					// remove fas(font-awesome solid) class and set to far(font-awesome regular)
					$icon.removeClass('fas js-selected').addClass('far');

					// update count
					var $voteCounter = $this.next();
					var prevCount = parseInt($voteCounter.text(), 10);
					$voteCounter.text(prevCount - 1);

					// update text
					var textNode = $icon[0].nextSibling;
					textNode.textContent = " {% trans 'Dislike' %}";
				},
				error: function(jqXHR, status, error) {
					displayToast('CUSTOM_ERROR', jqXHR.responseJSON['message']);
				}
			});
		} else {
			// if user is adding a new downvote
			var voteAction = 'vote';

			// user should have number of points required
			// the isNumeric func is in the js file
			if (isNumeric(userPoints) && userPoints < requiredDownvotePoints) {
				var toastMsg = {% blocktrans %} "You need at least <strong>{{ required_downvote_points }} points</strong> to be able to add a dislike." {% endblocktrans %};
				displayToast('CUSTOM_ERROR', toastMsg);
				return false;
			}

			$.ajax({
				url: url,
				type: 'POST',
				data: {id: id, vote_type: voteType, thread_type: threadType, action: voteAction},
				beforeSend: function (xhr) {
					xhr.setRequestHeader("X-CSRFToken", csrfToken);
				},
				success: function(response) {
					// remove far class and set to fas
					$icon.removeClass('far').addClass('fas js-selected');

					// update count
					var $voteCounter = $this.next();
					var prevCount = parseInt($voteCounter.text(), 10);
					$voteCounter.text(prevCount + 1);

					// update text
					var textNode = $icon[0].nextSibling;
					textNode.textContent = " {% trans 'Disliked' %}";
				},
				error: function(jqXHR, status, error) {
					displayToast('CUSTOM_ERROR', jqXHR.responseJSON['message']);
				}
			});
		}
	});

	/** FOLLOWING **/
	// do this only if user isn't owner of question
	{% if user.id != question.poster_id %}
		// no need to complicate following by creating another template and script
		// besides it is used in only two templates; (both questions detail templates)
		$('.js-follow-button').click(function(event) {
			// if user isn't logged in
			if (!userId) {
				displayToast('LOGIN_REQUIRED');
				return false;
			}

			var $this = $(this);
			var id = parseInt(this.dataset.id, 10);
			var url = "{% url 'qa_site:academic-follow-toggle' %}";
			var $followUnfollowSpan = $('.js-follow-unfollow-text').first();
			
			// if user is trying to undo the follow
			if ($this.hasClass('js-selected')) {
				var voteAction = 'recall-follow';

				$.ajax({
					url: url,
					type: 'POST',
					data: {id: id, action: voteAction},
					dataType: 'json',
					beforeSend: function (xhr) {
						xhr.setRequestHeader("X-CSRFToken", csrfToken);
					},
					success: function(result) {
						$this.removeClass('js-selected btn-secondary').addClass('btn-outline-secondary');
						$followUnfollowSpan.text('{{ follow_text }}');
						displayToast('FOLLOW_TOGGLE', false);
					},
					error: function(jqXHR, status, error) {
						displayToast('CUSTOM_ERROR', jqXHR.responseJSON['message']);
					}
				});
			} else {
				// if user is following question
				var voteAction = 'follow';

				$.ajax({
					url: url,
					type: 'POST',
					data: {id: id, action: voteAction},
					dataType: 'json',
					beforeSend: function (xhr) {
						xhr.setRequestHeader("X-CSRFToken", csrfToken);
					},
					success: function(result) {
						$this.removeClass('btn-outline-secondary').addClass('js-selected btn-secondary');
						$followUnfollowSpan.text('{{ unfollow_text }}');
						displayToast('FOLLOW_TOGGLE', true);
					},
					error: function(jqXHR, status, error) {
						displayToast('CUSTOM_ERROR', jqXHR.responseJSON['message']);
					}
				});
			}
		});
	{% endif %}
</script>
<script>
	const PAGE_URL = "{{ request.build_absolute_uri }}";

	// CKEDITOR global settings: https://ckeditor.com/docs/ckeditor4/latest/api
	CKEDITOR.config.title = "{% trans 'Rich Text Editor' %}";
	CKEDITOR.config.extraPlugins = 'mentions,codesnippet,eqneditor,wordcount';
	// see https://ckeditor.com/docs/ckeditor4/latest/guide/dev_allowed_content_rules.html
	CKEDITOR.config.extraAllowedContent = 'span[class](*)';
	CKEDITOR.config.toolbar = [
		// 'EqnEditor' is from CodeCogs, it needs the eqneditor plugin
		['Bold', 'Italic', 'Underline', 'Strike'],
		['Subscript', 'Superscript'],
		// codesnippet plugin needs to be loaded for CodeSnippet to work.
		['Smiley', 'Link', 'Blockquote', '-', 'Table', 'EqnEditor', 'CodeSnippet'],
		['NumberedList', 'BulletedList'],
		'/',
		['Format', 'HorizontalRule', '-', 'Outdent', 'Indent'],
		['JustifyLeft', 'JustifyCenter', 'JustifyRight', '-', 'BidiLtr', 'BidiRtl'],
		['Undo', 'Redo', '-', 'Maximize', 'Preview']
	];
	CKEDITOR.config.wordcount = {
		'showRemaining': true,
		'showParagraphs': false,
		'showCharCount': true,
		'showWordCount': false,
		'maxCharCount': 3000,
	};

	CKEDITOR.on('instanceReady', function(ev) {
		// If there's no internet inform user when equation editor button is clicked
		var ele = ev.editor.element.$;
		var toolbarEl = document.querySelector(`#cke_${ele.id || 'editor1'}`);
		var codecogEl = toolbarEl.querySelector('a.cke_button.cke_button__eqneditor');

		codecogEl.addEventListener('click', function() {
			// Internet connection is required to load assets
			if (!navigator.onLine) {
				// Prevent the dialog from displaying in futture cases
				this.onclick = null;
				var msg = "{% blocktrans %}You need to be connected to the internet to use this feature. If you're connected, please refresh this page and try again.{% endblocktrans %}";
				displayToast('CUSTOM_ERROR', msg);
				return;
			}
		});
	});
	CKEDITOR.on('dialogDefinition', function(ev) {
		// Apparently, clicking "ok" on the codecogs dialog menu doesn't work.
		// (dialog doesnt' close). Add listener to make it properly close the dialog.
		var dialogName = ev.data.name, dialogDef = ev.data.definition;
		if (dialogName == "eqneditorDialog") {
			// Apparently, this does the trick.
			dialogDef.onOk = function() {};
		}
	});

	{% if LANGUAGE_CODE != 'en' %}
	moment.locale('{{ LANGUAGE_CODE }}');
	{% endif %}

	var jqc;  // variable to store jquery-comment object
	var usersMentioned = [];
	$.ajax({
		type: 'GET',
		url: "{% url 'qa_site:users-mentioned' question.id %}?model_name=AcademicComment&for_jquery=1",
		success: function(result, status, jqXHR) {
			usersMentioned = result.data;
			console.log(result);

			function dataFeed(opts, callback) {
				// opts is an object { query: '', marker: ''}. 
				// query is the current value(eg. serg), marker is the symbol used(eg. @)
				var matchProperty = 'fullname';
				var data = usersMentioned.filter(function(user) {
					var containsSearchTerm = user[matchProperty].indexOf(opts.query.toLowerCase()) != -1;
					var isNotSelf = user.id != userId;
					return containsSearchTerm && isNotSelf;
				});

				data = data.sort(function(a, b) {
					return a[matchProperty].localeCompare(b[matchProperty]);
				});

				callback(data);
			}

			CKEDITOR.config.mentions = [{
				feed: dataFeed,
				itemTemplate: '<li data-id="{id}"><strong>{fullname}</strong></li>',
				outputTemplate: '<span class="tag ping">@{fullname}</span><span>&nbsp;</span>',
				minChars: 0
			}];
		},
		error: function(jqXHR, status, error) {
			console.error(error);
		}
	});

	/* Prepare flagging */
	const COMMENT_MODEL_NAME = 'AcademicComment';

	// Question poster & anonymous users can't flag
	if (userId) {
		var flagModal = document.querySelector('.js-flag-report-modal');
		var reportIcon = document.querySelector('.js-flag-report-icon');
		var modalClose = document.querySelector('.report-modal-close');
		var initModelName = reportIcon.dataset.modelName, initModelId = reportIcon.dataset.modelId;

		var flagSuccessToast = document.querySelector('.js-flag-success-toast');

		/** Reset data attributes of flag modal after modal is closed */
		function resetFlagModal(ev) {
			// ev.target will equal ev.currentTarget when the click is done outside the modal content
			if (ev.target == modalClose || ev.target == ev.currentTarget) {
				reportIcon.dataset.modelName = initModelName;
				reportIcon.dataset.modelId = initModelId;
			}
		}

		flagModal.addEventListener('click', resetFlagModal);
		modalClose.addEventListener('click', resetFlagModal);
	}

	{# jquery-comments config, https://viima.github.io/jquery-comments #}
	$('#academic-qstn-comments').comments({
		textareaPlaceholderText: "{% trans 'Add an answer or comment' %}",
		newestText: "{% trans 'Newest' %}",
		oldestText: "{% trans 'Oldest' %}",
		popularText: "{% trans 'Popular' %}",
		attachmentsText: "{% trans 'Attachments' %}",
		sendText: "{% trans 'Send' %}",
		replyText: "{% trans 'Reply' %}",
		editText: "{% trans 'Edit' %}",
		editedText: "{% trans 'Edited' %}",
		youText: "{% trans 'You' %}",
		saveText: "{% trans 'Save' %}",
		deleteText: "{% trans 'Delete' %}",
		viewAllRepliesText: "{% trans 'View all' %} " + "__replyCount__" + " {% trans 'replies' %} ",
		hideRepliesText: "{% trans 'Hide replies' %}",
		noCommentsText: "{% trans 'No comments' %}",
		noAttachmentsText: "{% trans 'No attachments' %}",
		attachmentDropText: "{% trans 'Drop files here' %}",
		roundProfilePictures: true,
		enableDeletingCommentWithReplies: true,
		profilePictureUrl: (function() {
			{% with profile_image=user.social_profile.profile_image %}
			var url = "{% if profile_image %}{{ profile_image.url }}{% endif %}";
			{% endwith %}
			return url;
		})(),
		currentUserIsAdmin: false,
		enableAttachments: true,
		fieldMappings: {
			// Add new fields(not known by jquery-comments) so that they will be included
			// in commentJSON
			has_flagged: 'has_flagged',
			downvote_count: 'downvote_count',
			user_has_downvoted: 'user_has_downvoted'
		},
		_textareaContent: '',
		_comments: [],
		_getCommentLi: function(commentId) {
			return document.querySelector(`#academic-qstn-comments li.comment[data-id='${commentId}']`);
		},
		_permissions: {},
		_parseComment: function(comment) {
			// Convert pings to appropriate format
			$(Object.keys(comment.pings)).each(function(index, userId) {
				var username = comment.pings[userId];
				var pingText = '@' + username;
				comment.content = comment.content.replace(new RegExp('@' + userId, 'g'), pingText);
			}); 
			
			return comment;
		},
		_onFlagComment: function(comment) {
			var that = this, ev = event;
			
			// Display modal and update reportIcon attributes & flag button
			flagModal.style.display = 'block';
			reportIcon.dataset.modelId = comment.id;
			reportIcon.dataset.modelName = COMMENT_MODEL_NAME;

			function onSuccess() {
				var target = ev.target, btn, icon;
				if (target.tagName.toLowerCase() === 'button') {
					btn = target;
					icon = btn.querySelector('i');
				} else if (target.tagName.toLowerCase() === 'i') {
					icon = target;
					btn = icon.parentElement;
				} else {
					// throw "Invalid event target";
					return;
				}
				
				icon.setAttribute('class', 'fa-flag fas ms-2');
				btn.setAttribute('title', "{% trans 'Remove flag' %}");
				btn.firstChild.nodeValue = "{% trans 'Remove flag' %}";
				// Normally, we just have to remove the flagComment event listener.
				// But since we used bind() to add the event, there is no simple way to remove the binded
				// function since bind() creates a new function. 
				// So lets just clone the previous button (event listeners won't be attached) then replace it
				var newBtn = btn.cloneNode(true);  // true for deep cloning (with child nodes)
				btn.replaceWith(newBtn);
				newBtn.addEventListener('click', that._onUnflagComment.bind(that, comment));

				// Remove the event listener after executing it.
				flagSuccessToast.removeEventListener('shown.bs.toast', onSuccess);
			}
				
			flagSuccessToast.addEventListener('shown.bs.toast', onSuccess);
		},
		_onUnflagComment: function(comment) {
			var that = this, ev = event;
			// Update reportIcon attributes
			reportIcon.dataset.modelId = comment.id;
			reportIcon.dataset.modelName = COMMENT_MODEL_NAME;

			submitFlagForm(reportIcon, 'remove');

			function onSuccess() {
				var target = ev.target, btn, icon;
				if (target.tagName.toLowerCase() === 'button') {
					btn = target;
					icon = btn.querySelector('i');
				} else if (target.tagName.toLowerCase() === 'i') {
					icon = target;
					btn = icon.parentElement;
				} else {
					// throw "Invalid event target";
					return;
				}

				// Set reportIcon attributes back to original & update flag button
				reportIcon.dataset.modelName = initModelName;
				reportIcon.dataset.modelId = initModelId;

				icon.setAttribute('class', 'fa-flag far ms-2');
				btn.setAttribute('title', "{% trans 'Report comment' %}");
				btn.firstChild.nodeValue = "{% trans 'Report comment' %}";

				var newBtn = btn.cloneNode(true);  
				btn.replaceWith(newBtn);
				newBtn.addEventListener('click', that._onFlagComment.bind(that, comment));
				
				flagSuccessToast.removeEventListener('shown.bs.toast', onSuccess);
			}

			flagSuccessToast.addEventListener('shown.bs.toast', onSuccess);
		},
		_deletedFilenames: [],
		_onCloseCommentingField: function() {
			var target = (function() {
				if (event.target.tagName.toLowerCase() === 'span') {
					return event.target;
				} else if (event.target.tagName.toLowerCase() === 'i') {
					return event.target.parentElement;
				}
			})();

			// Remove image & attachment tag from rerendered comment.
			// For some reason, clicking the save button also triggers this function; 
			// and only way to differentiate is coz the target is null
			if (target) {
				for (var filename of this._deletedFilenames) {
					var wrapper = target.closest('.comment-wrapper');
					var imgEl = wrapper.querySelector(`img[src*="${filename}"]`);
					imgEl.closest('div').remove();
	
					wrapper.querySelector(`a.tag.attachment[href*="${filename}"]`);
				}
			}
		},
		_onDeleteAttachment: function(commentId) {
			// Normally the attachment would instantly be removed. But we stop it so as to 
			// first delete the file
			event.stopImmediatePropagation();
			var that = this;
			
			var target = (function() {
				if (event.target.tagName.toLowerCase() === 'span') {
					return event.target;
				} else if (event.target.tagName.toLowerCase() === 'i') {
					return event.target.parentElement;
				}
			})();
			var filename = target.previousSibling.nodeValue;

			// Send request to delete file
			$.ajax({
				type: 'DELETE',
				url: "{% url 'qa_site:comments-cl' 'DiscussComment' %}" + `${commentId}/attachments/${filename}/`,
				beforeSend: function (xhr) {
					xhr.setRequestHeader("X-CSRFToken", csrfToken);
				},
				success: function(result) {
					// Delete attachment 
					target.closest('.attachment').remove();
					that._deletedFilenames.push(filename);
				},
				error: function(jqXHR, status, ajaxError) {
					if (jqXHR.status === 404) {
						var msg = "{% trans 'The file was not found on our server. Please refresh the page and try again.' %}";
						displayToast('CUSTOM_ERROR', msg);
					} else {
						displayToast('ERROR_OCCURRED');
					}
				}
			});
		},
		_onClickSendButton: function() {
			var textarea = event.target.closest('.textarea-wrapper').querySelector('.textarea');
			this._textareaContent = textarea.innerHTML;
		},
		refresh: function() {
			jqc = this;
			var $comments = $('#academic-qstn-comments li.comment');
			var that = this;

			/** Function to Highlight parent comment when share icon is hovered */
			function enableHighlightParent(comment, replyToSpan) {
				if (comment && replyToSpan) {
					// console.log(comment) shows that comment.parent is sometimes null 
					// i.e in cases like the first reply, this sometimes print the parent comment...
					// so in cases where the parent comment is present, we add the event listener
					var parentId = comment.parent;
					if (parentId !== null) {
						replyToSpan.addEventListener('mouseover', function(ev) {
							var parentCommentWrp = document.querySelector(`#academic-qstn-comments li.comment[data-id='${parentId}'] .comment-wrapper`);
							parentCommentWrp.style.backgroundColor = 'lightgray';

							// After some time, set color back to initial
							setTimeout(function() {
								parentCommentWrp.style.backgroundColor = 'initial';
							}, 1500);
						});
					}
				}
			}

			/** Create & insert dropdown menu for comment */
			function generateMenu(comment) {
				// `this` refers to the li.comment or span.actions

				// Prepare share item(tooltip)
				var linkHref = `comment-${comment.id}`, dropdownBtnId = `comment-${comment.id}-menu-btn`;
				var commentLink = PAGE_URL + '#' + linkHref;

				// Prevent adding another menu. This is becoz after replying to comment,
				// parent comment is rerendered.
				if ($('#' + dropdownBtnId).length !== 0)
					return;

				const WHATSAPP_SHARER = 'https://wa.me/', FACEBOOK_SHARER = 'https://www.facebook.com/sharer/sharer.php';
				const TWITTER_SHARER ='https://www.twitter.com/intent/tweet', TWITTER_HANDLE = 'camerschools';
				var shareBtn = document.createElement('button');
				shareBtn.innerHTML = '{% trans "Share comment" %} <i class="fas fa-share ms-1" aria-hidden="true"></i>';
				setAttributes(shareBtn, {
					'class': "w-100 mt-2 link-secondary no-style-button js-share-tooltip js-comment-share-tooltip",
					'data-bs-toggle': 'tooltip',
					'data-bs-trigger': 'click',
					'data-bs-custom-class': "share-tooltip",
					'data-bs-html': "true",
					'data-bs-container': "body",
					'title': `
						<h6 class="text-nowrap mt-2">{% trans "Share a link to this comment" %}</h6>
						<input class="form-control mb-3 py-1 js-link-input" type="text" value="${commentLink}" title="${commentLink}" readonly>
						<div class="text-start mb-2">
							<button class="no-style-button text-purple js-copy-button">{% trans 'Copy link' %}</button>
							<a class="text-decoration-none link-secondary mx-3" href="${FACEBOOK_SHARER}?u=${commentLink}&t={{ title }}" target="_blank">
								<span class="visually-hidden">{% trans 'Share on Facebook' %}</span>
								<i class="fab fa-facebook-square fa-lg" aria-hidden="true"></i>
							</a>
							<a class="text-decoration-none me-3" href="${TWITTER_SHARER}?url=${commentLink}&via={{ TWITTER_HANDLE }}&text={{ title }}" target="_blank">
								<span class="visually-hidden">{% trans 'Share on Twitter' %}</span>
								<i class="fab fa-twitter-square fa-lg" aria-hidden="true"></i>
							</a>
							<a class="text-decoration-none link-success" href="${WHATSAPP_SHARER}?text=${commentLink}" target="_blank">
								<span class="visually-hidden">{% trans 'Share on WhatsApp' %}</span>
								<i class="fab fa-whatsapp fa-lg" aria-hidden="true"></i>
							</a>
						</div>
						<button type="button" class="btn-close btn-close-white" onclick="shareCloseBtnClick()" aria-label="{% trans 'Close' %}"></button>					
					`
				});

				// Create dropdown menu.
				// Normally a 'dropdown' class is also needed(for positioning), but apparently 
				// in this case adding it will cause problems...
				var dropdown = document.createElement("div");
				dropdown.setAttribute('class', 'd-inline');
				dropdown.innerHTML = `
					<button type="button" class="float-end" id=${dropdownBtnId} data-bs-toggle="dropdown" aria-expanded="false">
						<i class="fa fa-ellipsis-v"></i>	
					</button>
					<ul class="dropdown-menu py-1" role="menu" aria-labelledby=${dropdownBtnId}>
					</ul>
				`;

				var menu = dropdown.querySelector('ul');

				// Add share to menu
				var shareLi = document.createElement('li');
				shareLi.appendChild(shareBtn);
				menu.appendChild(shareLi);

				// Enable flagging only if comment is not poster's (Edit button is not present)
				var $actions;
				if (this.classList.contains('actions')) {
					$actions = $(this);
				} else {
					$actions = $(this).find('.actions').first();
				}
				if ($actions.find('.action.edit').length == 0) { 
					var flagTitle = comment.has_flagged ? "{% trans 'Remove flag' %}" : "{% trans 'Report comment' %}";
					var flagClass = 'fa-flag ' + (comment.has_flagged ? 'fas' : 'far');
					var separatorStr = `
						<span class="separator" style="vertical-align: text-bottom;">.</span> 
					`;
					var flagBtn = document.createElement("button");
					flagBtn.setAttribute("class", "mt-3 mb-2 text-danger w-100");
					flagBtn.innerHTML = `${flagTitle} <i class="ms-2 ${flagClass}"></i>`;	

					if (userId) {
						if (comment.has_flagged) {
							// set the `that` object as the this object in that handler, and pass the comment
							// as an argument.
							// Binding is necessary since we want to pass an argument(comment) to the handler
							flagBtn.addEventListener('click', that._onUnflagComment.bind(that, comment));
						} else {
							flagBtn.addEventListener('click', that._onFlagComment.bind(that, comment));
						}
					} else {
						// If user is unauthed, display login required toast.
						flagBtn.addEventListener('click', displayToast.bind(null, 'LOGIN_REQUIRED'));
					}

					// Add flag to menu
					var flagLi = document.createElement('li');
					flagLi.appendChild(flagBtn);
					menu.appendChild(flagLi);
				} else {
					// Else prevent or make upvote button for current user invalid.
					// (If Edit button is present, that means comment belongs to the current user)
					// var $upvoteBtn = $actions.children('.action.upvote').first();
					// var $thumbsUpIcon = $upvoteBtn.children('i').first();
					// $thumbsUpIcon.css('cursor', 'default');

					// No need to remove error toast telling user that he can't vote for his post;
					// the user should know what is happening.
					// Also, apparently, after clicking the upvote button, the cursor turns back to
					// pointer. No need to bother changing it back to default.
				}

				$actions.append(dropdown);
			}

			$comments.each(function (idx) {
				var $this = $(this), commentId = parseInt(this.dataset.id, 10);
				var comment = that._comments.find(obj => obj.id === commentId);
				
				/* Properly display ckeditor comment */
				var contentDiv = this.querySelector('.content');
				var timeEl = contentDiv.querySelector('time.edited');
				
				// AFter updating the innerHtml as above, the textContent will also change.
				// So we use the new textContent ...
				contentDiv.innerHTML = contentDiv.innerHTML.replaceAll('input type="button" value="<', '').replaceAll('" data-cke-editable="1" contenteditable="false"&gt;', '');
				contentDiv.innerHTML = contentDiv.textContent;

				// Edited comments will timeEl not null
				if (timeEl) {
					contentDiv.insertAdjacentElement('beforeend', timeEl);
					var previousNode = timeEl.previousSibling;

					// timeEl should normally be preceeded by a text node (like "Edited 10 minutes ago").
					// Remove this text node since we want to insert the appropriate time element.
					if (previousNode.nodeType == 3) {
						previousNode.remove();
					}
				} 

				// Add comment hyperlink (appending #comment-<id> to the url should go to comment)
				var linkEl = document.createElement("a");
				var linkHref = `comment-${comment.id}`;
				linkEl.setAttribute("name", linkHref);
				this.firstChild.before(linkEl);

				// Highlight parent comment when share icon is hovered
				var replySpan = this.querySelector('.reply-to');
				enableHighlightParent(comment, replySpan);

				// Add downvote button
				var $action = $this.find('.actions').first();
				var separatorStr = `
					<span class="separator" style="vertical-align: text-bottom;">.</span> 
				`;
				var downvoteBtn = document.createElement('button');
				downvoteBtn.addEventListener('click', that._downvoteComment.bind(that, comment));
				downvoteBtn.setAttribute('class', 'action downvote');
				downvoteBtn.innerHTML = `
					<span class="downvote-count me-1">${comment.downvote_count}</span>
					<i class="fa fa-thumbs-down align-middle"></i>
				`;

				if (comment.user_has_downvoted) {
					downvoteBtn.classList.add('highlight-font');
				}

				var $upvoteBtn = $action.children('.action.upvote');
				$upvoteBtn.after(separatorStr, downvoteBtn);

				generateMenu.call(this, comment);
			});

			/** Make pings with social profile's cursor pointer */
			document.querySelectorAll('input.tag.ping').forEach(function (ele) {
				if (ele.value) {
					var user = usersMentioned.find(user => '@' + user.fullname === ele.value);
					if (user && user.social_profile_url) {
						ele.style.cursor = 'pointer';
					}
				}
			});

			// Initialize new comment share button tooltips,
			// use default allowList to allow button elements ()
			bootstrap.Tooltip.Default.allowList.button = ['onclick'];
			initTooltips();

			// Add listeners for copy button
			var commentTooltips = document.querySelectorAll('.js-comment-share-tooltip'); 
			for (var i = 0; i < commentTooltips.length; i++) {
				commentTooltips[i].addEventListener('inserted.bs.tooltip', function() {
					// `this` refers to the element containing the tooltip (Share button in this case)
					var tooltip = bootstrap.Tooltip.getInstance(this);
					var copyBtn = tooltip.tip.querySelector('.js-copy-button');
					copyBtn.addEventListener('click', onCopyLink);
				});
			}

			// Add listener to first save button.edit
			// save class is used for edited & new comments span, while send class
			// only for new comments.
			var sendSpan = document.querySelector('span.save');
			sendSpan.addEventListener('click', that._onClickSendButton.bind(that));

			// Regenerate menu for comment after it disappears.
			// Apparently, after editing comment or replying, the comment-wrapper is recreated.
			insertionQ('.comment-wrapper .actions').every(function(ele) {
				var commentId = parseInt(ele.closest('li.comment').dataset.id, 10);
				generateMenu.call(ele, that._comments.find(obj => obj.id === commentId));
		  });

			// Listen to when new comment is added, so as to enable highlighting its parent
			insertionQ('li.comment.by-current-user').every(function (ele) {
				var commentId = parseInt(ele.dataset.id, 10);
				var comment = that._comments.find(obj => obj.id === commentId);
				var replySpan = ele.querySelector('.reply-to');
				enableHighlightParent(comment, replySpan);

				// Convert textcontent to innerHTML so as to properly render tags 
				ele.querySelector('.content').innerHTML = that._textareaContent;
			});

			// Listen to when reply is about to be added; so as to appropriately place 
			// commenting field on page.
			// ALGORITHM: After commenting field is added, if it isn't in viewport, find the hyperlink
			// before it and go to the link. If no link is present, create one then link to it.
			insertionQ('.data-container .commenting-field').every(function (ele) {
				var textarea = ele.querySelector('.textarea');
				if (!isElementInViewport(ele)) {
					// prevElement is not present(is null) when reply is the first reply to the comment
					var prevElement = ele.previousSibling, href;
					if (prevElement === null || prevElement.nodeName.toLowerCase() !== 'a') {
						href = uid().replace('id', '');  // uid() function is in base.js
						var link = document.createElement('a');
						link.setAttribute("name", href);
						link.setAttribute('class', 'd-block');
						ele.insertAdjacentElement('beforebegin', link);
					} else {
						href = prevElement.getAttribute('name');
					}

					// If the hash has already been set, resetting it to the same value won't have
					// any effect (won't scroll to the link). So we clear it then set it to the link. 
					// To clear it without scrolling, we use the replaceState(or pushState) function...
					if (location.hash.replace('#', '') == href) {
						history.replaceState({}, '', location.pathname);
					}

					location.hash = href;
					textarea.focus();
				}

				// Add listener to commenting close button
				ele.querySelector('span.close').addEventListener('click', that._onCloseCommentingField.bind(that));

				// Add listener to close button of attachments
				ele.querySelectorAll('.attachments span.delete').forEach(function(span) {
					var commentId = span.closest('li.comment').dataset.id;
					span.addEventListener('click', that._onDeleteAttachment.bind(that, commentId));
				});

				// Add listener to send button
				var sendSpan = ele.querySelector('span.save');
				sendSpan.addEventListener('click', that._onClickSendButton.bind(that));

				// Add ckeditor. Use innerHTML to parse html chars.
				var id = uid();
				textarea.setAttribute('id', id);

				var editor = CKEDITOR.inline(id, {
					on: {
						instanceReady: function(evt) {
							var ele = evt.editor.element.$;
							console.log(ele);
							ele.innerHTML = ele.innerHTML.replaceAll('<input type="button" value="<', '').replace('" data-cke-editable="1" contenteditable="false"&gt;');

							// Remember the textContent will also change after changing innerHTML.
							ele.innerHTML = ele.textContent;
						},
					}
				});
			});

			insertionQ('.cke_dialog_container .cke_dialog_footer ').every(function (ele) {

			});
		},	
		getComments: function(success, error) {
			var that = this;

			$.ajax({
				type: 'GET',
				url: "{% url 'qa_site:comments-cl' 'AcademicComment' %}",
				success: function(result) {
					console.log(result);
					var data = result.data;

					for (var comment of data) {
						that._permissions[comment.id] = {
							cannotUpdate: false,
							cannotUpdateMessage: '',
							cannotDelete: false,
							cannotDeleteMessage: '',
						};
					}
					that._comments = data;
					success(data);
				},
				error: error,
			});
		},
		postComment: function(commentJSON, success, error) {
			var that = this;

			if (!userId) {
				displayToast('LOGIN_REQUIRED');
				return error();
			}

			// Apparently, commentJSON disregards the formatting done by ckeditor.
			// so when posting, we update the content with that of the ckeditor textarea.
			commentJSON.content = this._textareaContent;
			commentJSON = this._parseComment(commentJSON);

			// Get pinged users ids
			var pingedIds = (function() {
				var reg = /@[A-ZÀ-Ÿa-z]{4}[A-ZÀ-Ÿa-z0-9-_]{0,11}/g;
				// matches will contain array like ['@user1', '@user2']
				var matches = commentJSON.content.match(reg) || [];
				var res = [];

				for (var match of matches) {
					for (var user of usersMentioned) {
						if ('@' + user.fullname === match) {
							if (!res.includes(user.id)) {
								res.push(user.id);
								break;
							}
						}
					}
				}

				return res;
			})();

			// See https://viima.github.io/jquery-comments/#link-5 for info on attachments
			// Create form data and append all other fields but attachments
			var formData = new FormData();
			formData.append('content', commentJSON.content);
			formData.append('parent_id', commentJSON.parent || '');
			formData.append('question_id', {{ question.id }});
			formData.append('pingedIds', pingedIds);

			// Append attachments to be created to the form data
			var attachmentsToBeCreated = commentJSON.attachments.filter(function(attachment) {
				return !attachment.id;
			});
			$(attachmentsToBeCreated).each(function(idx, attachment) {
				formData.append('attachments', attachment.file);
			});

			// Save the comment together with the attachments
			$.ajax({
				type: 'POST',
				url: "{% url 'qa_site:comments-cl' 'DiscussComment' %}",
				beforeSend: function (xhr) {
					xhr.setRequestHeader("X-CSRFToken", csrfToken);
				},
				data: formData,
				// contentType and processData are both required & should be false
				contentType: false,
				processData: false,
				success: function(result) {
					var data = result.data;

					// Add comment to list of comments & permission to list of permissions
					that._comments.push(data);
					that._permissions[data.id] = {
						cannotUpdate: false,
						cannotUpdateMessage: '',
						cannotDelete: false,
						cannotDeleteMessage: ''
					};

					success(that._parseComment(data));
				},
				error: error
			});
		},
		putComment: function(commentJSON, success, error) {
			// After trying a PUT request, if it fails, we store the result in the
			// permissions array so as to prevent subsequent requests.
			var that = this, id = commentJSON.id;
			var permission = this._permissions[id];
			
			// Verify if comment can be changed
			if (permission.cannotUpdate) {
				displayToast('CUSTOM_ERROR', permission.cannotUpdateMessage);
				return error();
			} 

			commentJSON.content = this._textareaContent;
			commentJSON = this._parseComment(commentJSON);

			// Get pinged users ids
			var pingedIds = (function() {
				var reg = /@[A-ZÀ-Ÿa-z]{4}[A-ZÀ-Ÿa-z0-9-_]{0,11}/g;
				// matches will contain array like ['@user1', '@user2']
				var matches = commentJSON.content.match(reg) || [];
				var res = [];

				for (var match of matches) {
					for (var user of usersMentioned) {
						if ('@' + user.fullname === match) {
							if (!res.includes(user.id)) {
								res.push(user.id);
								break;
							}
						}
					}
				}

				return res;
			})();
			
			var data = {
				'content': commentJSON.content,
				'pingedIds': pingedIds
			};

			// Append attachments to be created to the form data
			var formData = new FormData();
			var attachmentsToBeCreated = commentJSON.attachments.filter(function(attachment) {
				return !attachment.id;
			});
			$(attachmentsToBeCreated).each(function(idx, attachment) {
				formData.append('attachments', attachment.file);
			});

			$.ajax({
				type: 'PUT',
				// use cl instead of cud then append id...
				// since javascript vars do not work in python
				url: "{% url 'qa_site:comments-cl' 'AcademicComment' %}" + encodeURIComponent(id + '/' + JSON.stringify(data) + '/'),
				data: formData,
				contentType: false,
				processData: false,
				beforeSend: function (xhr) {
					xhr.setRequestHeader("X-CSRFToken", csrfToken);
				},
				success: function(result) {
					var newComment = that._parseComment(result.data);
					success(newComment);

					// Convert textcontent to innerHTML so as to properly render tags 
					var commentEl = document.querySelector(`[data-id="${newComment.id}"`);
					commentEl.querySelector('.content').innerHTML = that._textareaContent;
				},
				error: function(jqXHR, status, ajaxError) {
					if (jqXHR.status === 403) {
						var response = jqXHR.responseJSON;
						displayToast('CUSTOM_ERROR', response.message);
						// Mark that comment can't be edited
						permission.cannotUpdate = true;
						permission.cannotUpdateMessage = response.message;
					}
					error();
				}
			});
		},
		deleteComment: function(commentJSON, success, error) {
			var that = this, id = commentJSON.id;
			var permission = that._permissions[id];

			// Verify if comment can be deleted
			if (permission.cannotDelete) {
				displayToast('CUSTOM_ERROR', permission.cannotDeleteMessage);
				return error();
			} 

			$.ajax({
				type: 'DELETE',
				url: "{% url 'qa_site:comments-cl' 'AcademicComment' %}" + id + '/',
				beforeSend: function (xhr) {
					xhr.setRequestHeader("X-CSRFToken", csrfToken);
				},
				success: success, // No need to bother removing the comment from list of permissions or comments...
				error: function (jqXHR, status, ajaxError) {
					if (jqXHR.status === 403) {
						var response = jqXHR.responseJSON;
						displayToast('CUSTOM_ERROR', response.message);
						// Mark that comment can't be deleted
						permission.cannotDelete = true;
						permission.cannotDeleteMessage = response.message;
					}
					error();
				}
			});
		},
		upvoteComment: function(commentJSON, success, error) {
			if (!userId) {
				displayToast('LOGIN_REQUIRED');
				return error();
			}

			// In this function, commentJSON.user_has_upvoted is set to its opposite. 
			// i.e. if the original commentJSON had it to false, in this function, it is set to true
			// and vice versa. 
			var hadUpvoted = !(commentJSON.user_has_upvoted), that = this;
			var upvotesURL = "{% url 'qa_site:academic-thread-vote' %}";

			// If user is creator of comment, he can't vote
			if (userId == commentJSON.creator) {
				displayToast('SELF_VOTE');
				return error();
			} else {
				// Recalling upvote
				if(hadUpvoted) {
					$.ajax({
						type: 'POST',
						url: upvotesURL,
						data: {
							id: commentJSON.id, 
							vote_type: 'up', 
							thread_type: 'comment', 
							action: 'recall-vote'
						},
						beforeSend: function (xhr) {
							xhr.setRequestHeader("X-CSRFToken", csrfToken);
						},
						success: function() {
							success(commentJSON);
						},
						error: function() {
							displayToast('ERROR_OCCURRED');
							error();
						}
					});
				} else {
					$.ajax({
						type: 'POST',
						url: upvotesURL,
						data: {
							id: commentJSON.id, 
							vote_type: 'up', 
							thread_type: 'comment', 
							action: 'vote'
						},
						beforeSend: function (xhr) {
							xhr.setRequestHeader("X-CSRFToken", csrfToken);
						},
						success: function() {
							success(commentJSON);

							// Decrement downvote count if comment was previously downvoted.
							// Apparently after the execution of this function, the upvote button
							// is replaced with a new element.
							var downvoteBtn = that._getCommentLi(commentJSON.id).querySelector('button.action.downvote');
							if (downvoteBtn.classList.contains('highlight-font')) {
								var countSpan = downvoteBtn.querySelector('span');
								countSpan.textContent = parseInt(countSpan.textContent, 10) - 1;
								downvoteBtn.classList.remove('highlight-font');
							}
						},
						error: function() {
							displayToast('ERROR_OCCURRED');
							error();
						}
					});
				}
			}
		},
		_downvoteComment: function(commentJSON) {
			if (!userId) {
				displayToast('LOGIN_REQUIRED');
				return;
			}

			var downvoteBtn = event.target.parentElement;
			var countSpan = downvoteBtn.querySelector('span');
			var previousDownvoteCount = parseInt(countSpan.textContent, 10);

			// With upvoteComment, they update the user_has_upvoted field immediately after
			// the click. But since the user_has_downvoted field is an added field,
			// we need to handle it manually coz it won't be updated in the commentJSON.
			var hadDownvoted = downvoteBtn.classList.contains('highlight-font');
			var downvotesURL = "{% url 'qa_site:academic-thread-vote' %}";

			// If user is creator of comment, he can't vote
			if (userId == commentJSON.creator) {
				displayToast('SELF_VOTE');
				return;
			} else {
				// Recalling downvote
				if(hadDownvoted) {
					$.ajax({
						type: 'POST',
						url: downvotesURL,
						data: {
							id: commentJSON.id, 
							vote_type: 'down', 
							thread_type: 'comment', 
							action: 'recall-vote'
						},
						beforeSend: function (xhr) {
							xhr.setRequestHeader("X-CSRFToken", csrfToken);
						},
						success: function() {
							var newDownvoteCount = previousDownvoteCount - 1;
							countSpan.textContent = newDownvoteCount;
							downvoteBtn.classList.remove('highlight-font');
						},
						error: function() {
							displayToast('ERROR_OCCURRED');
						}
					});
				} else {
					$.ajax({
						type: 'POST',
						url: downvotesURL,
						data: {
							id: commentJSON.id, 
							vote_type: 'down', 
							thread_type: 'comment', 
							action: 'vote'
						},
						beforeSend: function (xhr) {
							xhr.setRequestHeader("X-CSRFToken", csrfToken);
						},
						success: function() {
							var newDownvoteCount = previousDownvoteCount + 1;
							countSpan.textContent = newDownvoteCount;
							downvoteBtn.classList.add('highlight-font');

							// Likewise decrement upvote count if comment was previously upvoted
							// and mark comment has not upvoted.
							// Apparently commentJSON.user_has_upvoted is also unreliable.
							// It gives the original user_has_upvoted value
							var upvoteBtn = downvoteBtn.previousElementSibling.previousElementSibling;
							if (upvoteBtn.classList.contains('highlight-font')) {
								var upvoteSpan = upvoteBtn.querySelector('span');
								upvoteSpan.textContent = parseInt(upvoteSpan.textContent, 10) - 1;
								upvoteBtn.classList.remove('highlight-font');
							}
						},
						error: function() {
							displayToast('ERROR_OCCURRED');
						}
					});
				}
			}
		},
		pingClicked: function(userId) {
			// We can't use userId because we've changed the structure of the ping element.
			// (from input tag to span tag...)
			var el = event.target;
			var user = usersMentioned.find(u => '@' + u.fullname === el.textContent);
			// Precaution in case user is undefined
			if (user && user.social_profile_url) {
				location.href = user.social_profile_url;
			}
		},
		timeFormatter: function(time) {
			return moment(time).fromNow();
		},
		validateAttachments: function(attachments, callback) {
			var validAttachments = [], validTypes = ['png', 'jpg', 'jpeg'];
			var maxFileSizeMb = 3;

			$(attachments).each(function(idx, attachment) {
				var { file, mime_type } = attachment;

				// Validate extension
				var ext = mime_type.split('/').at(-1);
				if (!validTypes.includes(ext)) {
					return;
				}

				// Validate size
				var fileSizeMb = file.size / 1000000;
				if (fileSizeMb <= maxFileSizeMb) {
					validAttachments.push(attachment);
				}
			});

			callback(validAttachments);
		},

	});
</script>
{% endblock %}